#pragma once

#include "pendule_pi/switch.hpp"
#include "pendule_pi/encoder.hpp"
#include "pendule_pi/motor.hpp"
#include <memory>


namespace pendule_pi {

/// Class that allows to control the Pendulum.
class Pendule {
public:
  /// Internal struct that can be passed to specify pin connections.
  struct Pins {
    const int motor_pwm; ///< Pin used to send the PWM signal to the motor.
    const int motor_dir; ///< Pin used to change the motor direction.
    const int left_switch; ///< Pin used to read the state of the left switch.
    const int right_switch; ///< Pin used to read the state of the right switch.
    const int position_encoder_a; ///< First phase of the encoder used to measure the position of the base.
    const int position_encoder_b; ///< Second phase of the encoder used to measure the position of the base.
    const int angle_encoder_a; ///< First phase of the encoder used to measure the angle of the pendulum.
    const int angle_encoder_b; ///< Second phase of the encoder used to measure the angle of the pendulum.
    /// Initialize the pins to a default.
    Pins();
  };

  /// Exception class to be thrown when the pendulum has not been calibrated.
  class NotCalibrated : public std::runtime_error {
  public:
    /// Fills the error message.
    NotCalibrated() : std::runtime_error("Pendule was not calibrated yet!") {}
    /// Fills the error message.
    /** @param src the "source" of this exception, *e.g.*, the method that was
      *   called before performing the calibration.
      */
    NotCalibrated(const std::string& src) : std::runtime_error(src + ": Pendule was not calibrated yet!") {}
  };

  /// Exception class to be thrown when the calibration fails for any reason.
  class CalibrationFailed : public std::runtime_error {
  public:
    /// Fills the error message.
    /** @param why reason for the failure.
      */
    CalibrationFailed(const std::string& why) : std::runtime_error("Pendulum calibration failed! Reason: " + why) {}
  };

  /// Exception class to be thrown when emergency stop is requested.
  class EmergencyStop : public std::runtime_error {
  public:
    /// Fills the error message.
    /** @param why reason to stop.
      */
    EmergencyStop(const std::string& why) : std::runtime_error("Pendulum::eStop has been called! Reason: " + why) {}
  };

  /// Creates the pendulum, using the default pin connections.
  /** This version will delegate construction to the version with signature
    * Pendule(double,double,double,const Pins&). The pins are thus set to a
    * default for all the hardware components.
    * @param meters_per_step distance covered by the base when the associated
    *   encoder registers a single step. As an example, say that the rotatory
    *   encoder features 100 steps per revolution and that it is connected to
    *   the base using a belt and a pully of diameter 10mm. Due to the pully,
    *   the transmission factor is thus
    *   \f$ 2 \pi 10 \text{mm} / \text{rotation} \f$.
    *   Since the encoder features 100 steps per rotation, the final factor is:
    *   \f$ \frac{2 \pi 10}{100} \text{mm} / \text{step}
    *       = 2 \pi 10^{-4} \text{m} / \text{step} \f$.
    * @param radians_per_step angle spanned by the pendulum when the associated
    *   encoder registers a single step. As an example, say that the rotatory
    *   encoder features 100 steps per revolution and that it is directly
    *   connected to the pendulum. The transmission factor is thus
    *   \f$ \frac{2 \pi}{100} \text{rad} / \text{step} \f$.
    * @param rest_angle value, in radians, that should be returned by angle()
    *   when the pendulum points downward due to gravity.
    * @note As mentioned in the Encoder class, the number of steps per
    *   revolution that an Encoder instance can register is actually 4 times
    *   the one declared by the constructor. As an example, with a 600 steps
    *   encoder, the corresponding Encoder object will count 2400 steps per
    *   full rotation. This factor is added internally here, and therefore
    *   **you should not take it into account when calculating the parameters
    *   meters_per_step and radians_per_step**.
    */
  Pendule(
    double meters_per_step,
    double radians_per_step,
    double rest_angle
  );

  /// Creates the pendulum, using the given pin connections.
  /** This version allows to specify the pins to be used for hardware
    * components. The objects representing the hardware are generated by
    * forwarding the call to the Pendule constructor which takes pointers as
    * last parameters.
    * @param meters_per_step distance covered by the base when the associated
    *   encoder registers a single step. As an example, say that the rotatory
    *   encoder features 100 steps per revolution and that it is connected to
    *   the base using a belt and a pully of diameter 10mm. Due to the pully,
    *   the transmission factor is thus
    *   \f$ 2 \pi 10 \text{mm} / \text{rotation} \f$.
    *   Since the encoder features 100 steps per rotation, the final factor is:
    *   \f$ \frac{2 \pi 10}{100} \text{mm} / \text{step}
    *       = 2 \pi 10^{-4} \text{m} / \text{step} \f$.
    * @param radians_per_step angle spanned by the pendulum when the associated
    *   encoder registers a single step. As an example, say that the rotatory
    *   encoder features 100 steps per revolution and that it is directly
    *   connected to the pendulum. The transmission factor is thus
    *   \f$ \frac{2 \pi}{100} \text{rad} / \text{step} \f$.
    * @param rest_angle value, in radians, that should be returned by angle()
    *   when the pendulum points downward due to gravity.
    * @param pins a Pins object in which all pins are explicitly given by the
    *   user.
    * @note As mentioned in the Encoder class, the number of steps per
    *   revolution that an Encoder instance can register is actually 4 times
    *   the one declared by the constructor. As an example, with a 600 steps
    *   encoder, the corresponding Encoder object will count 2400 steps per
    *   full rotation. This factor is added internally here, and therefore
    *   **you should not take it into account when calculating the parameters
    *   meters_per_step and radians_per_step**.
    */
  Pendule(
    double meters_per_step,
    double radians_per_step,
    double rest_angle,
    const Pins& pins
  );

  /// Creates the pendulum, using the given components.
  /** This constructor gives the highest level of control over the definition
    * of the hardware components, allowing the user to fully specify the
    * instances to be used.
    * @param meters_per_step distance covered by the base when the associated
    *   encoder registers a single step. As an example, say that the rotatory
    *   encoder features 100 steps per revolution and that it is connected to
    *   the base using a belt and a pully of diameter 10mm. Due to the pully,
    *   the transmission factor is thus
    *   \f$ 2 \pi 10 \text{mm} / \text{rotation} \f$.
    *   Since the encoder features 100 steps per rotation, the final factor is:
    *   \f$ \frac{2 \pi 10}{100} \text{mm} / \text{step}
    *       = 2 \pi 10^{-4} \text{m} / \text{step} \f$.
    * @param radians_per_step angle spanned by the pendulum when the associated
    *   encoder registers a single step. As an example, say that the rotatory
    *   encoder features 100 steps per revolution and that it is directly
    *   connected to the pendulum. The transmission factor is thus
    *   \f$ \frac{2 \pi}{100} \text{rad} / \text{step} \f$.
    * @param rest_angle value, in radians, that should be returned by angle()
    *   when the pendulum points downward due to gravity.
    * @param motor the Motor that allows to actuate the base. It should be
    *   wired in such a way that a positive command moves the base to the right.
    * @param left_switch the Switch that should be reached when the base moves
    *   in the negative direction.
    * @param right_switch the Switch that should be reached when the base moves
    *   in the positive direction.
    * @param position_encoder rotary encoder used to measure the position of
    *   the base.
    * @param angle_encoder rotary encoder used to measure the angle of the
    *   pendulum.
    * @note As mentioned in the Encoder class, the number of steps per
    *   revolution that an Encoder instance can register is actually 4 times
    *   the one declared by the constructor. As an example, with a 600 steps
    *   encoder, the corresponding Encoder object will count 2400 steps per
    *   full rotation. This factor is added internally here, and therefore
    *   **you should not take it into account when calculating the parameters
    *   meters_per_step and radians_per_step**.
    * @warning Ownership of the objects contained in the pointers passed to this
    *   constructor is claimed. You should not keep any copy of these objects,
    *   and in particular you should let this class manage their memory.
    *   Any of the unique pointers passed to this constructor can alternatively
    *   be `nullptr`. In this case, default instances will be generated and
    *   managed internally.
    */
  Pendule(
    double meters_per_step,
    double radians_per_step,
    double rest_angle,
    std::unique_ptr<Motor> motor,
    std::unique_ptr<Switch> left_switch,
    std::unique_ptr<Switch> right_switch,
    std::unique_ptr<Encoder> position_encoder,
    std::unique_ptr<Encoder> angle_encoder
  );

  /// Initialize the pendulum.
  void calibrate();

  /// Perform state estimation.
  /** @param dt time (in seconds) that elapsed since the last call to update().
    */
  void update(double dt);

  /// Forwards the command to the actuator.
  /** Applies the given PWM to the motor.
    * @param pwm the desired command.
    * @return false if the command exceeded the maximum/minimum values and thus
    *   had to be saturated.
    */
  bool setCommand(int pwm);

  /// Get the current filtered position (in meters) of the base.
  inline const double& position() const { return position_; }
  /// Get the current filtered angle (in radians) of the pendulum.
  inline const double& angle() const { return angle_; }
  /// Get the current filtered velocity (in meters per second) of the base.
  inline const double& linearVelocity() const { return linvel_; }
  /// Get the current filtered velocity (in radians per second) of the pendulum.
  inline const double& angularVelocity() const { return angvel_; }

  /// Allow to access min_position_steps_.
  /** If the pendulum has not been calibrated, this method will throw an
    * exception.
    * @return the value of min_position_steps_.
    */
  const int& minPositionSteps() const;

  /// Allow to access max_position_steps_.
  /** If the pendulum has not been calibrated, this method will throw an
    * exception.
    * @return the value of max_position_steps_.
    */
  const int& maxPositionSteps() const;

  /// Allow to access mid_position_steps_.
  /** If the pendulum has not been calibrated, this method will throw an
    * exception.
    * @return the value of mid_position_steps_.
    */
  const int& midPositionSteps() const;

  /// Emergency stop.
  void eStop(const std::string& why);

private:
  bool calibrated_; ///< Variable that is set to true once the pendulum calibration has been completed.
  bool emergency_stopped_; ///< Variable that is set to true when the pendulum has to stop.
  // Hardware components
  std::unique_ptr<Motor> motor_; ///< Actuator to move the base of the pendulum.
  std::unique_ptr<Switch> left_switch_; ///< Left switch (should be near to the motor).
  std::unique_ptr<Switch> right_switch_; ///< Right switch (should be near to the encoder).
  std::unique_ptr<Encoder> position_encoder_; ///< Encoder to read the current position of the base.
  std::unique_ptr<Encoder> angle_encoder_; ///< Encoder to read the current angle of the pendulum.
  // State variables
  double position_; ///< Current position of the moving base.
  double angle_; ///< Current angle of the pendulum.
  double linvel_; ///< Current velocity of the moving base.
  double angvel_; ///< Current velocity of the pendulum.
  // Calibration values
  int min_position_steps_; ///< Encoder reading when the base is at the minimum position.
  int max_position_steps_; ///< Encoder reading when the base is at the maximum position.
  int mid_position_steps_; ///< Encoder reading when the base is at the middle position.
  const double meters_per_step_; ///< Multiplicative factor to convert from encoder steps to meters.
  const double radians_per_step_; ///< Multiplicative factor to convert from encoder steps to radians.
  const double rest_angle_; ///< Position of the pendulum when it is at rest.

  /// Axuiliary method that converts steps into meters.
  inline double steps2meters(const int& steps) { return meters_per_step_*(steps-mid_position_steps_); }
  /// Axuiliary method that converts steps into radians.
  inline double steps2radians(const int& steps) { return radians_per_step_*steps-rest_angle_; }

  /// Auxiliary method that creates a Switch instance with default settings on the given pin.
  static inline std::unique_ptr<Switch> makeDefaultSwitch(int pin) { return std::make_unique<Switch>(pin, Switch::NORMALLY_UP, Switch::WITH_PULL_RESISTOR); }
};

}
